/* This file is part of GDB.

   Copyright 2002 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
 
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.

   --

   This file was generated by the program igen */

#ifndef SUPPORT_C
#define SUPPORT_C

#include "sim-main.h"
#include "idecode.h"
#include "itable.h"
#include "support.h"

INLINE_SUPPORT\
(instruction_address)
semantic_illegal
(SIM_DESC sd,
 instruction_address cia)
{
#line 82 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  SignalException (ReservedInstruction, 0);
  sim_engine_abort (SD, CPU, cia, "Internal function must longjump\n");
  return cia;
}
#line 44 "support.c"

INLINE_SUPPORT\
(address_word)
delayslot32
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word target)
{
#line 103 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA;
  CIA = CIA + 4; /* NOTE not mips16 */
  STATE |= simDELAYSLOT;
  delay_insn = IMEM32 (CIA); /* NOTE not mips16 */
  ENGINE_ISSUE_PREFIX_HOOK();
  idecode_issue (CPU_, delay_insn, (CIA));
  STATE &= ~simDELAYSLOT;
  return target;
}
#line 63 "support.c"

INLINE_SUPPORT\
(address_word)
nullify_next_insn32
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 117 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  sim_events_slip (SD, 1);
  dotrace (SD, CPU, tracefh, 2, CIA + 4, 4, "load instruction");
  return CIA + 8;
}
#line 75 "support.c"

INLINE_SUPPORT\
(address_word)
loadstore_ea
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word base, address_word offset)
{
#line 139 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  return base + offset;
}
#line 85 "support.c"

INLINE_SUPPORT\
(int)
not_word_value
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned_word value)
{
#line 173 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  /* For historical simulator compatibility (until documentation is
     found that makes these operations unpredictable on some of these
     architectures), this check never returns true.  */
  return 0;
}
#line 98 "support.c"

INLINE_SUPPORT\
(void)
unpredictable
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 211 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
}
#line 107 "support.c"

INLINE_SUPPORT\
(int)
check_mf_cycles
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history, signed64 time, const char *new)
{
#line 235 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  if (history->mf.timestamp + 3 > time)
    {
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: %s at 0x%08lx too close to MF at 0x%08lx\n",
  			itable[MY_INDEX].name,
  			new, (long) CIA,
  			(long) history->mf.cia);
      return 0;
    }
  return 1;
}
#line 125 "support.c"

INLINE_SUPPORT\
(int)
check_mt_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history)
{
#line 255 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = check_mf_cycles (SD_, history, time, "MT");
  history->mt.timestamp = time;
  history->mt.cia = CIA;
  return ok;
}
#line 139 "support.c"

INLINE_SUPPORT\
(int)
check_mf_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *history, hilo_history *peer)
{
#line 286 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = 1;
  if (peer != NULL
      && peer->mt.timestamp > history->op.timestamp
      && history->mt.timestamp < history->op.timestamp
      && ! (history->mf.timestamp > history->op.timestamp
  	    && history->mf.timestamp < peer->mt.timestamp)
      && ! (peer->mf.timestamp > history->op.timestamp
  	    && peer->mf.timestamp < peer->mt.timestamp))
    {
      /* The peer has been written to since the last OP yet we have
         not */
      sim_engine_abort (SD, CPU, CIA, "HILO: %s: MF at 0x%08lx following OP at 0x%08lx corrupted by MT at 0x%08lx\n",
  			itable[MY_INDEX].name,
  			(long) CIA,
  			(long) history->op.cia,
  			(long) peer->mt.cia);
      ok = 0;
    }
  history->mf.timestamp = time;
  history->mf.cia = CIA;
  return ok;
}
#line 170 "support.c"

INLINE_SUPPORT\
(int)
check_mult_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *hi, hilo_history *lo)
{
#line 321 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (check_mf_cycles (SD_, hi, time, "OP")
  	    && check_mf_cycles (SD_, lo, time, "OP"));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}
#line 187 "support.c"

INLINE_SUPPORT\
(int)
check_div_hilo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, hilo_history *hi, hilo_history *lo)
{
#line 360 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  signed64 time = sim_events_time (SD);
  int ok = (check_mf_cycles (SD_, hi, time, "OP")
  	    && check_mf_cycles (SD_, lo, time, "OP"));
  hi->op.timestamp = time;
  lo->op.timestamp = time;
  hi->op.cia = CIA;
  lo->op.cia = CIA;
  return ok;
}
#line 204 "support.c"

INLINE_SUPPORT\
(void)
check_u64
(SIM_DESC sd, instruction_address cia, int MY_INDEX, instruction_word insn)
{
#line 384 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  // The check should be similar to mips64 for any with PX/UX bit equivalents.
}
#line 214 "support.c"

INLINE_SUPPORT\
(void)
do_addiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 460 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  if (NotWordValue (GPR[rs]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = EXTEND32 (GPR[rs] + EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 228 "support.c"

INLINE_SUPPORT\
(void)
do_addu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 487 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] + GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 242 "support.c"

INLINE_SUPPORT\
(void)
do_and
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 514 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] & GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 254 "support.c"

INLINE_SUPPORT\
(void)
do_daddiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 1074 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = GPR[rs] + EXTEND16 (immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 266 "support.c"

INLINE_SUPPORT\
(void)
do_daddu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1096 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] + GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 278 "support.c"

INLINE_SUPPORT\
(void)
do_ddiv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1166 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed64 n = GPR[rs];
    signed64 d = GPR[rt];
    signed64 hi;
    signed64 lo;
    if (d == 0)
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else if (d == -1 && n == SIGNED64 (0x8000000000000000))
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else
      {
  	lo = (n / d);
  	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 313 "support.c"

INLINE_SUPPORT\
(void)
do_ddivu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1211 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned64 n = GPR[rs];
    unsigned64 d = GPR[rt];
    unsigned64 hi;
    unsigned64 lo;
    if (d == 0)
      {
  	lo = SIGNED64 (0x8000000000000000);
  	hi = 0;
      }
    else
      {
  	lo = (n / d);
  	hi = (n % d);
      }
    HI = hi;
    LO = lo;
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 343 "support.c"

INLINE_SUPPORT\
(void)
do_div
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1251 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    signed32 n = GPR[rs];
    signed32 d = GPR[rt];
    if (d == 0)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else if (n == SIGNED32 (0x80000000) && d == -1)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else
      {
  	LO = EXTEND32 (n / d);
  	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 374 "support.c"

INLINE_SUPPORT\
(void)
do_divu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt)
{
#line 1295 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  check_div_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  {
    unsigned32 n = GPR[rs];
    unsigned32 d = GPR[rt];
    if (d == 0)
      {
  	LO = EXTEND32 (0x80000000);
  	HI = EXTEND32 (0);
      }
    else
      {
  	LO = EXTEND32 (n / d);
  	HI = EXTEND32 (n % d);
      }
  }
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 400 "support.c"

INLINE_SUPPORT\
(void)
do_dmultx
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd, int signed_p)
{
#line 1334 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  unsigned64 lo;
  unsigned64 hi;
  unsigned64 m00;
  unsigned64 m01;
  unsigned64 m10;
  unsigned64 m11;
  unsigned64 mid;
  int sign;
  unsigned64 op1 = GPR[rs];
  unsigned64 op2 = GPR[rt];
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  /* make signed multiply unsigned */
  sign = 0;
  if (signed_p)
    {
      if ((signed64) op1 < 0)
  	{
  	  op1 = - op1;
  	  ++sign;
  	}
      if ((signed64) op2 < 0)
  	{
  	  op2 = - op2;
  	  ++sign;
  	}
    }
  /* multiply out the 4 sub products */
  m00 = ((unsigned64) VL4_8 (op1) * (unsigned64) VL4_8 (op2));
  m10 = ((unsigned64) VH4_8 (op1) * (unsigned64) VL4_8 (op2));
  m01 = ((unsigned64) VL4_8 (op1) * (unsigned64) VH4_8 (op2));
  m11 = ((unsigned64) VH4_8 (op1) * (unsigned64) VH4_8 (op2));
  /* add the products */
  mid = ((unsigned64) VH4_8 (m00)
  	 + (unsigned64) VL4_8 (m10)
  	 + (unsigned64) VL4_8 (m01));
  lo = U8_4 (mid, m00);
  hi = (m11
  	+ (unsigned64) VH4_8 (mid)
  	+ (unsigned64) VH4_8 (m01)
  	+ (unsigned64) VH4_8 (m10));
  /* fix the sign */
  if (sign & 1)
    {
      lo = -lo;
      if (lo == 0)
  	hi = -hi;
      else
  	hi = -hi - 1;
    }
  /* save the result HI/LO (and a gpr) */
  LO = lo;
  HI = hi;
  if (rd != 0)
    GPR[rd] = lo;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 465 "support.c"

INLINE_SUPPORT\
(void)
do_dmult
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1394 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  do_dmultx (SD_, rs, rt, rd, 1);
}
#line 475 "support.c"

INLINE_SUPPORT\
(void)
do_dmultu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1422 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  do_dmultx (SD_, rs, rt, rd, 0);
}
#line 485 "support.c"

INLINE_SUPPORT\
(void)
do_dsll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 1448 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = GPR[rt] << shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 497 "support.c"

INLINE_SUPPORT\
(void)
do_dsllv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1485 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = GPR[rt] << s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 510 "support.c"

INLINE_SUPPORT\
(void)
do_dsra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 1506 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = ((signed64) GPR[rt]) >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 522 "support.c"

INLINE_SUPPORT\
(void)
do_dsrav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1545 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = ((signed64) GPR[rt]) >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 535 "support.c"

INLINE_SUPPORT\
(void)
do_dsrl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 1566 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = (unsigned64) GPR[rt] >> shift;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 547 "support.c"

INLINE_SUPPORT\
(void)
do_dsrlv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1605 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  int s = MASKED64 (GPR[rs], 5, 0);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = (unsigned64) GPR[rt] >> s;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 560 "support.c"

INLINE_SUPPORT\
(void)
do_dsubu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 1649 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] - GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 572 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset)
{
#line 1747 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU (SD, 0), cia, read_map, access+1, vaddr, read_transfer, sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  LoadMemory (&memval, NULL, uncached, access, paddr, vaddr, isDATA, isREAL);
  byte = ((vaddr & mask) ^ bigendiancpu);
  return (memval >> (8 * byte));
}
#line 600 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load_left
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 1770 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;
  unsigned_word lhs_mask;
  unsigned_word temp;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
  	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
  	   (long) ((unsigned64) paddr >> 32), (long) paddr,
  	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  LoadMemory (&memval, NULL, uncached, byte, paddr, vaddr, isDATA, isREAL);
  if (word == 0)
    {
      /* GPR_31..32-NR_LHS_BITS_ = memval_NR_LHS_BITS-1..0_ */
      temp = (memval << nr_rhs_bits);
    }
  else
    {
      /* GPR_31..32-NR_LHS_BITS = memval_32+NR_LHS_BITS..32_ */
      temp = (memval >> nr_lhs_bits);
    }
  lhs_mask = LSMASK (nr_lhs_bits + nr_rhs_bits - 1, nr_rhs_bits);
  rt = (rt & ~lhs_mask) | (temp & lhs_mask);

  /* fprintf (stderr, "l[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx & 0x%08lx%08lx -> 0x%08lx%08lx\n",
  	   (long) ((unsigned64) memval >> 32), (long) memval,
  	   (long) ((unsigned64) temp >> 32), (long) temp,
  	   (long) ((unsigned64) lhs_mask >> 32), (long) lhs_mask,
  	   (long) (rt >> 32), (long) rt); */
  return rt;
}
#line 661 "support.c"

INLINE_SUPPORT\
(unsigned_word)
do_load_right
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 1826 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isLOAD, &paddr, &uncached, isTARGET, isREAL);
  /* NOTE: SPEC is wrong, has `BigEndianMem == 0' not `BigEndianMem != 0' */
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr = paddr & ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  /* NOTE: SPEC is wrong, had `byte' not `access - byte'.  See SW. */
  LoadMemory (&memval, NULL, uncached, access - (access & byte), paddr, vaddr, isDATA, isREAL);
  /* printf ("lr: 0x%08lx %d@0x%08lx 0x%08lx\n",
     (long) paddr, byte, (long) paddr, (long) memval); */
  {
    unsigned_word screen = LSMASK (8 * (access - (byte & access) + 1) - 1, 0);
    rt &= ~screen;
    rt |= (memval >> (8 * byte)) & screen;
  }
  return rt;
}
#line 696 "support.c"

INLINE_SUPPORT\
(void)
do_mfhi
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd)
{
#line 2204 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  check_mf_hilo (SD_, HIHISTORY, LOHISTORY);
  TRACE_ALU_INPUT1 (HI);
  GPR[rd] = HI;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 709 "support.c"

INLINE_SUPPORT\
(void)
do_mflo
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd)
{
#line 2230 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  check_mf_hilo (SD_, LOHISTORY, HIHISTORY);
  TRACE_ALU_INPUT1 (LO);
  GPR[rd] = LO;
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 722 "support.c"

INLINE_SUPPORT\
(void)
do_mult
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2386 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  signed64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((signed64)(signed32) GPR[rs])
  	  * ((signed64)(signed32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 743 "support.c"

INLINE_SUPPORT\
(void)
do_multu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2427 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  unsigned64 prod;
  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  prod = (((unsigned64)(unsigned32) GPR[rs])
  	  * ((unsigned64)(unsigned32) GPR[rt]));
  LO = EXTEND32 (VL4_8 (prod));
  HI = EXTEND32 (VH4_8 (prod));
  if (rd != 0)
    GPR[rd] = LO;
  TRACE_ALU_RESULT2 (HI, LO);
}
#line 764 "support.c"

INLINE_SUPPORT\
(void)
do_nor
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2467 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ~ (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 776 "support.c"

INLINE_SUPPORT\
(void)
do_or
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2491 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = (GPR[rs] | GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 788 "support.c"

INLINE_SUPPORT\
(void)
do_ori
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned immediate)
{
#line 2516 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = (GPR[rs] | immediate);
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 800 "support.c"

INLINE_SUPPORT\
(void)
do_store
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word word)
{
#line 2562 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? (mask ^ access) : 0);
  address_word bigendiancpu = (BigEndianCPU ? (mask ^ access) : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  if ((vaddr & access) != 0)
    {
      SIM_CORE_SIGNAL (SD, STATE_CPU(SD, 0), cia, read_map, access+1, vaddr, write_transfer, sim_core_unaligned_signal);
    }
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = ((paddr & ~mask) | ((paddr & mask) ^ reverseendian));
  byte = ((vaddr & mask) ^ bigendiancpu);
  memval = (word << (8 * byte));
  StoreMemory (uncached, access, memval, 0, paddr, vaddr, isREAL);
}
#line 828 "support.c"

INLINE_SUPPORT\
(void)
do_store_left
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 2585 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  unsigned int word;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;
  int nr_lhs_bits;
  int nr_rhs_bits;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem == 0)
    paddr = paddr & ~access;

  /* compute where within the word/mem we are */
  byte = ((vaddr ^ bigendiancpu) & access); /* 0..access */
  word = ((vaddr ^ bigendiancpu) & (mask & ~access)) / (access + 1); /* 0..1 */
  nr_lhs_bits = 8 * byte + 8;
  nr_rhs_bits = 8 * access - 8 * byte;
  /* nr_lhs_bits + nr_rhs_bits == 8 * (accesss + 1) */
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx 0x%08lx%08lx %d:%d %d+%d\n",
  	   (long) ((unsigned64) vaddr >> 32), (long) vaddr,
  	   (long) ((unsigned64) paddr >> 32), (long) paddr,
  	   word, byte, nr_lhs_bits, nr_rhs_bits); */

  if (word == 0)
    {
      memval = (rt >> nr_rhs_bits);
    }
  else
    {
      memval = (rt << nr_lhs_bits);
    }
  /* fprintf (stderr, "s[wd]l: 0x%08lx%08lx -> 0x%08lx%08lx\n",
  	   (long) ((unsigned64) rt >> 32), (long) rt,
  	   (long) ((unsigned64) memval >> 32), (long) memval); */
  StoreMemory (uncached, byte, memval, 0, paddr, vaddr, isREAL);
}
#line 878 "support.c"

INLINE_SUPPORT\
(void)
do_store_right
(SIM_DESC sd, instruction_address cia, int MY_INDEX, unsigned access, address_word base, address_word offset, unsigned_word rt)
{
#line 2630 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  address_word mask = (WITH_TARGET_WORD_BITSIZE == 64 ? 0x7 : 0x3);
  address_word reverseendian = (ReverseEndian ? -1 : 0);
  address_word bigendiancpu = (BigEndianCPU ? -1 : 0);
  unsigned int byte;
  address_word paddr;
  int uncached;
  unsigned64 memval;
  address_word vaddr;

  vaddr = loadstore_ea (SD_, base, offset);
  AddressTranslation (vaddr, isDATA, isSTORE, &paddr, &uncached, isTARGET, isREAL);
  paddr = (paddr ^ (reverseendian & mask));
  if (BigEndianMem != 0)
    paddr &= ~access;
  byte = ((vaddr & mask) ^ (bigendiancpu & mask));
  memval = (rt << (byte * 8));
  StoreMemory (uncached, access - (access & byte), memval, 0, paddr, vaddr, isREAL);
}
#line 904 "support.c"

INLINE_SUPPORT\
(void)
do_sll
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 2825 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  unsigned32 temp = (GPR[rt] << shift);
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 917 "support.c"

INLINE_SUPPORT\
(void)
do_sllv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2865 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (GPR[rt] << s);
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 931 "support.c"

INLINE_SUPPORT\
(void)
do_slt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2891 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((signed_word) GPR[rs] < (signed_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 943 "support.c"

INLINE_SUPPORT\
(void)
do_slti
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 2915 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((signed_word) GPR[rs] < (signed_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 955 "support.c"

INLINE_SUPPORT\
(void)
do_sltiu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 2939 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], EXTEND16 (immediate));
  GPR[rt] = ((unsigned_word) GPR[rs] < (unsigned_word) EXTEND16 (immediate));
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 967 "support.c"

INLINE_SUPPORT\
(void)
do_sltu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 2964 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = ((unsigned_word) GPR[rs] < (unsigned_word) GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 979 "support.c"

INLINE_SUPPORT\
(void)
do_sra
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 2988 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  signed32 temp = (signed32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 994 "support.c"

INLINE_SUPPORT\
(void)
do_srav
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3016 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  signed32 temp = (signed32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1010 "support.c"

INLINE_SUPPORT\
(void)
do_srl
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rt, int rd, int shift)
{
#line 3045 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  unsigned32 temp = (unsigned32) GPR[rt] >> shift;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], shift);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1025 "support.c"

INLINE_SUPPORT\
(void)
do_srlv
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3072 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  int s = MASKED (GPR[rs], 4, 0);
  unsigned32 temp = (unsigned32) GPR[rt] >> s;
  if (NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rt], s);
  GPR[rd] = EXTEND32 (temp);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1041 "support.c"

INLINE_SUPPORT\
(void)
do_subu
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3125 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  if (NotWordValue (GPR[rs]) || NotWordValue (GPR[rt]))
    Unpredictable ();
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = EXTEND32 (GPR[rs] - GPR[rt]);
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1055 "support.c"

INLINE_SUPPORT\
(void)
do_xor
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, int rd)
{
#line 3445 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], GPR[rt]);
  GPR[rd] = GPR[rs] ^ GPR[rt];
  TRACE_ALU_RESULT (GPR[rd]);
}
#line 1067 "support.c"

INLINE_SUPPORT\
(void)
do_xori
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rs, int rt, unsigned16 immediate)
{
#line 3469 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  TRACE_ALU_INPUT2 (GPR[rs], immediate);
  GPR[rt] = GPR[rs] ^ immediate;
  TRACE_ALU_RESULT (GPR[rt]);
}
#line 1079 "support.c"

INLINE_SUPPORT\
(const char *)
str_FMT
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt)
{
#line 3500 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  switch (fmt)
    {
    case fmt_single: return "s";
    case fmt_double: return "d";
    case fmt_word: return "w";
    case fmt_long: return "l";
    case fmt_ps: return "ps";
    default: return "?";
    }
}
#line 1097 "support.c"

INLINE_SUPPORT\
(const char *)
str_TF
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int tf)
{
#line 3513 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  if (tf)
    return "t";
  else
    return "f";
}
#line 1110 "support.c"

INLINE_SUPPORT\
(const char *)
str_ND
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int nd)
{
#line 3521 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  if (nd)
    return "l";
  else
    return "";
}
#line 1123 "support.c"

INLINE_SUPPORT\
(const char *)
str_COND
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int cond)
{
#line 3529 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  switch (cond)
    {
    case 00: return "f";
    case 01: return "un";
    case 02: return "eq";
    case 03: return "ueq";
    case 04: return "olt";
    case 05: return "ult";
    case 06: return "ole";
    case 07: return "ule";
    case 010: return "sf";
    case 011: return "ngle";
    case 012: return "seq";
    case 013: return "ngl";
    case 014: return "lt";
    case 015: return "nge";
    case 016: return "le";
    case 017: return "ngt";
    default: return "?";
    }
}
#line 1152 "support.c"

INLINE_SUPPORT\
(void)
check_fmt
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, instruction_word insn)
{
#line 3571 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  if ((fmt != fmt_single) && (fmt != fmt_double))
    SignalException (ReservedInstruction, insn);
}
#line 1163 "support.c"

INLINE_SUPPORT\
(void)
check_fmt_p
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int fmt, instruction_word insn)
{
#line 3586 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  /* None of these ISAs support Paired Single, so just fall back to
     the single/double check.  */
  check_fmt (SD_, fmt, insn);
}
#line 1175 "support.c"

INLINE_SUPPORT\
(void)
check_fpu
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 3619 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/mips.igen"
  if (! COP_Usable (1))
    SignalExceptionCoProcessorUnusable (1);
}
#line 1186 "support.c"

INLINE_SUPPORT\
(address_word)
delayslot16
(SIM_DESC sd, instruction_address cia, int MY_INDEX, address_word nia, address_word target)
{
#line 1037 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/m16.igen"
  instruction_word delay_insn;
  sim_events_slip (SD, 1);
  DSPC = CIA; /* save current PC somewhere */
  STATE |= simDELAYSLOT;
  delay_insn = IMEM16 (nia); /* NOTE: mips16 */
  idecode_issue (CPU_, delay_insn, (nia));
  STATE &= ~simDELAYSLOT;
  return target;
}
#line 1203 "support.c"

INLINE_SUPPORT\
(address_word)
basepc
(SIM_DESC sd, instruction_address cia, int MY_INDEX)
{
#line 1050 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/m16.igen"
  if (STATE & simDELAYSLOT)
    {
      return DSPC; /* return saved address of preceeding jmp */
    }
  else
    {
      return CIA;
    }
}
#line 1220 "support.c"

INLINE_SUPPORT\
(const char *)
str_MFHI
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int hi)
{
#line 8 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/vr.igen"
  return hi ? "hi" : "";
}
#line 1230 "support.c"

INLINE_SUPPORT\
(const char *)
str_SAT
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int s)
{
#line 13 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/vr.igen"
  return s ? "s" : "";
}
#line 1240 "support.c"

INLINE_SUPPORT\
(const char *)
str_UNS
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int u)
{
#line 18 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/vr.igen"
  return u ? "u" : "";
}
#line 1250 "support.c"

INLINE_SUPPORT\
(void)
do_vr_mul_op
(SIM_DESC sd, instruction_address cia, int MY_INDEX, int rd, int rs, int rt, int accumulate_p, int store_hi_p, int unsigned_p, int saturate_p, int subtract_p, int short_p, int double_p)
{
#line 43 "/root/cs161/cs161-gdb-1.4/./gdb-6.0+cs161/sim/mips/vr.igen"
  unsigned64 lhs, x, y, xcut, ycut, product, result;

  check_mult_hilo (SD_, HIHISTORY, LOHISTORY);

  lhs = (!accumulate_p ? 0 : double_p ? LO : U8_4 (HI, LO));
  x = GPR[rs];
  y = GPR[rt];

  /* Work out the canonical form of X and Y from their significant bits.  */
  if (!short_p)
    {
      /* Normal sign-extension rule for 32-bit operands.  */
      xcut = EXTEND32 (x);
      ycut = EXTEND32 (y);
    }
  else if (unsigned_p)
    {
      /* Operands must be zero-extended 16-bit numbers.  */
      xcut = x & 0xffff;
      ycut = y & 0xffff;
    }
  else
    {
      /* Likewise but sign-extended.  */
      xcut = EXTEND16 (x);
      ycut = EXTEND16 (y);
    }
  if (x != xcut || y != ycut)
    sim_engine_abort (SD, CPU, CIA,
  		      "invalid multiplication operand at 0x%08lx\n",
  		      (long) CIA);

  TRACE_ALU_INPUT2 (x, y);
  product = (unsigned_p
  	     ? V8_4 (x, 1) * V8_4 (y, 1)
  	     : EXTEND32 (x) * EXTEND32 (y));
  result = (subtract_p ? lhs - product : lhs + product);
  if (saturate_p)
    {
      /* Saturate the result to 32 bits.  An unsigned, unsaturated
  	 result is zero-extended to 64 bits, but unsigned overflow
  	 causes all 64 bits to be set.  */
      if (!unsigned_p && (unsigned64) EXTEND32 (result) != result)
  	result = ((signed64) result < 0 ? -0x7fffffff - 1 : 0x7fffffff);
      else if (unsigned_p && (result >> 32) != 0)
  	result = (unsigned64) 0 - 1;
    }
  TRACE_ALU_RESULT (result);

  if (double_p)
    LO = result;
  else
    {
      LO = EXTEND32 (result);
      HI = EXTEND32 (VH4_8 (result));
    }
  if (rd != 0)
    GPR[rd] = store_hi_p ? HI : LO;
}
#line 1317 "support.c"


#endif /* _SUPPORT_C_*/
